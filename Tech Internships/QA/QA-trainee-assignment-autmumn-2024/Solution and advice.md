# **Стажировки для QA-инженеров в Авито: на что мы смотрим при проверке работ** 

Мы заинтересованы в том, чтобы вы хорошо выполнили свои задания при отборе на программы стажировок. Разбираем тестовое из осенней волны, чтобы подсветить основные ошибки и дать советы по улучшению. Подготовили для вас мини-гайд вместе с командой разработчиков-экспертов, которые проверяют решения.

В этом году тестовое состояло из двух заданий: первом мы предлагали найти баги и определить их приоритеты на тестовой странице поисковой выдачи Авито. Во втором нужно было написать автотесты API или UI.  
___  
### Задание 1. Поиск багов. 

**Вот на что мы обращали внимание при проверке этого задания:**

1. **Количество найденных багов.**  Мы составляем задания так, чтобы вы смогли найти максимум багов на странице и таким образом продемонстрировать свои знания. При этом их не так много, чтобы просто внести в решение мелкие недочеты и улучшения. 
2. **Описание бага**. Мы обращаем внимание на то, насколько правильно вы можете подсветить баг. При этом хорошо, если описание багов не избыточное.    
3. **Сколько найдено критичных багов.** Их было не так много, поэтому важно было найти все.    
4. **Насколько точно были определены приоритеты в найденных багах.** Это важный аспект при работе с багами как в тестовых заданиях, так и в разработке.    
5. Отдельный плюс ставили за аргументацию выставления приоритетов.

**Советы, как лучше выполнять подобные задания:**

1. **Определите главную функциональность страницы**. Что можно включить в список?  
    1. Поиск по тексту.    
    2. Работа фильтров.    
    3. Выдача объявлений.    
2. **Посмотрите на внешний вид**. Вам необходимо убедиться, что на странице нет багов, которые могут испортить репутацию компании.    
3. **Определите приоритеты**. Чтобы проверить себя, руководствуйтесь разделом priority/severity в ISTQB.  

___

### Задание 2. Автотесты. API или UI

В осеннем наборе мы хотели дать возможность стажерам проявить себя при написании не только UI-/e2e-тестов, но и API-автотестов, потому что этот навык также может быть очень полезным в различных проектах. Было предложено два варианта задания.

- UI-автотесты. Как будет организована работа с web-страницами? Какие проверки будут реализованы?  
- API-автотесты. Как ручки будут обрабатывать невалидные входные данные? Какой ответ уйдет пользователю с учетом разграничения доступа? Правильно ли ручки обрабатывают граничные значения?

Несмотря на очевидные различия в этих видах тестов, в заданиях есть и много общего. Помимо самих проверок, в автотестах мы обращали внимание на организацию и структуру проекта, прозрачную историю коммитов, чистоту кода и отсутствие его дублирования, применение техник тест-дизайна, паттернов программирования и автоматизации тестирования.  
Ниже рассмотрим некоторые моменты, с которыми столкнулись при проверке работ кандидатов. А с подробным текстом заданий можно ознакомиться по [ссылке](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autmumn-2024/QA-trainee-assignment-autumn-2024.md\#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-2).

#### Структура проекта  
Структура проекта, логика директорий и наименований файлов — это всё часть культуры работы с кодом.  
Если взять самые красивые, понятные и стабильные автотесты и сложить их в папку «new folder» с именами test_1, test_2 — они сразу станут непонятными и некрасивыми.  
Примеры: 

*Понятная структура и названия* 

![](https://github.com/user-attachments/assets/d28b01eb-a122-48b8-872c-a0bc3f636af0)

![](https://github.com/user-attachments/assets/bab5702d-6f38-4a1e-bf25-f733ffe59529)

![](https://github.com/user-attachments/assets/4bd4c03d-9b49-4deb-bf77-b432cee5a15e)

*Не только структура и названия, но и пояснение в README*

![](https://github.com/user-attachments/assets/69c9d63f-2c01-4230-b7dd-ef2d3ab2dc5d)

#### Инструкция   
Инструкция. Чем проще, тем лучше: склонировать, установить зависимости, запустить.  
Примеры: 

*Хороший пример*

1. Склонируйте к себе репозиторий, в котором хранится проект тестового задания, через выполнение команды в терминале  
    ```  
    git clone https://github.com/avito-tech/tech-internship.git
    ```  
    Или скачайте zip-архив по [ссылке](https://github.com/Herzenswearme/AvitoTech\_QA-trainee/archive/refs/heads/main.zip) и распакуйте его

2. Убедитесь, что на вашем компьютере установлен Python. В командной строке/терминале выполните команду  
    ```  
    python -v  
    ```    
Если он не установлен, то установите с официального [сайта Python](https://www.python.org/downloads/), выбрав подходящую версию для вашей операционной системы, и пройдите шаг сначала. В процессе установки обязательно поставьте галочку в чекбоксе "Add python.exe to PATH". 

3. Через командную строку/терминал перейдите в корневую директорию проекта, выполнив команду  
   ```  
   cd /здесь укажите путь до директории с проектом  
   ```
4. Установите необходимые зависимости из файла `requirements.txt`, выполнив команду    
   ```  
   pip install -r requirements.txt  
   ```  
   если она не выполняется, то попробуйте  
   ```  
   pip3 install -r requirements.txt  
   ```  
5. После выполнения предыдущего пункта установите необходимые бинарные файлы браузеров, выполнив команду  
   ```  
   playwright install  
   ```  
     
6. Наконец, запустите тесты, выполнив команду    
   ```  
   pytest -v  
   ```  
> Очень понятная инструкция, написанная живым человеческим языком. Уже здесь чувствуется, что кандидат делает решение максимально удобным для проверяющего.

#### Параметризация  
Сила автотестов — в повторяемости. Вы берёте входные данные, описываете в коде действия с ними и свои ожидания от результата.  
Если действия одни и те же, а меняются только входные данные — это нужно параметризировать. 

---  
```python  
@pytest.mark.parametrize("name", [10, True, 10.0, [10, True, 10.0], {"f": "f"}])  
```  
> Использована параметризация.  
> Что можно улучшить: стоит добавить разбиение на тест-кейсы для лучшей читаемости результатов тестов.  
---

```js  
export const positiveTestCase = {  
    CORRECT_ADVERT_ITEM: new Advert("phone", 85, 345209, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": 14  
    })  
}

export const negativeNumbers = {  
    ADVERT_WITH_NEGATIVE_PRICE: new Advert("phone", -85, 345209, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": 14  
    }),  
    ADVERT_WITH_NEGATIVE_SELLERID: new Advert("phone", 85, -345209, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": 14  
    }),  
    ADVERT_WITH_NEGATIVE_CONTACTS: new Advert("phone", 85, 345209, {  
        "contacts": -32,  
        "likes": 0,  
        "viewCount": 14  
    }),  
    ADVERT_WITH_NEGATIVE_LIKES: new Advert("phone", 85, 345209, {  
        "contacts": 32,  
        "likes": -35,  
        "viewCount": 14  
    }),  
    ADVERT_WITH_NEGATIVE_VIEWCOUNT: new Advert("phone", 85, 345209, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": -14  
    }),

}

export const tooBigNumbers = {  
    ADVERT_WITH_TOO_BIG_PRICE: new Advert("phone", 8500000000000000, 345209, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": 14  
    }),  
    ADVERT_WITH_TOO_LONG_SELLERID: new Advert("phone", 85, 34520987, {  
        "contacts": 32,  
        "likes": 0,  
        "viewCount": 14  
    }),  
}  
```  
> Хорошая разбивка тестовых данных на позитивные и негативные сценарии.  
> Параметризация с помощью структуры позволяет максимально полно описать что и почему тестируется.

---  
```python  
import json

class DataProvider:  
  """Класс DataProvider предназначен для загрузки и предоставления тестовых данных из JSON-файла.   
    
Он считывает данные из файла и позволяет извлекать их по ключам в формате, подходящем для тестов.  
  """

  def __init__(self, filename: str) -> None:  
    """Записывает содержимое файла filename в переменную self.data.  
    """  
    with open(filename) as filename:  
      self.data = json.load(filename)  
    
  def get(self, key):  
    """Обращается к тестовым данным data по ключу key и возвращает список значений.   
    """  
    data_list = []  
    for el in self.data.get(key):  
      data_list.append(el["value"])  
    return data_list  
```
> Реализован паттерн data provider, это позволяет вынести тестовые данные в отдельные JSON-файлы.  
> Таким образом параметризировать тесты еще удобнее.

#### Разнесение логики по разным классам(PageObject, PageElement etc)   
Код автотестов должен быть читаемым, отвечать принципам DRY и KISS.

---

```python  
from selenium.webdriver.common.by import By

class MainPageLocators:  
    CATEGORY_DROPDOWN = (By.XPATH, "(//div[contains(@class, 'ant-select-selector')])[2]")  # Локатор выпадающего списка категории  
    HEADER_LOGO = (By.CSS_SELECTOR, ".ant-col.css-17a39f8 > h1.ant-typography.css-17a39f8")  # Заголовок главной страницы  
    GAME_CARD_TITLE = (By.CSS_SELECTOR, "div._title_vlg32_45 > h1.ant-typography.css-17a39f8")  # Заголовок игры в карточке

class GameCardLocators:  
    BACK_BUTTON = (By.CSS_SELECTOR, ".ant-btn.ant-btn-primary.ant-btn-lg")  # Кнопка "Back to main"  
    GAME_CARD = (By.CSS_SELECTOR, ".ant-card-body")  # Полная карточка игры  
    GAME_GENRE = (By.XPATH, ".//div[contains(text(), 'Genre:')]/following-sibling::div")  # Жанр игры

class PaginationLocators:  
    NEXT_BUTTON = (By.CSS_SELECTOR, "li.ant-pagination-next")  
    PREV_BUTTON = (By.CSS_SELECTOR, "li.ant-pagination-prev")  
    CURRENT_PAGE = (By.CSS_SELECTOR, "li.ant-pagination-item-active")  
``` 
> В данном примере селекторы вынесены в отдельные классы по страницам, где они используются.  
> При изменении селекторов это поможет поправить их в одном месте.  
> Что можно улучшить: писать селекторы без привязки к позиции в верстке.

---  
```python  
class BasePage:

    def __init__(self, driver):  
        self.driver = driver  
        self.base_url = "https://makarovartem.github.io/frontend-avito-tech-test-assignment/"

    def find_element(self, locator, time=10):  
        return WebDriverWait(self.driver, time).until(EC.presence_of_element_located(locator))

    def find_clickable_element(self, locator, time=15):  
        return WebDriverWait(self.driver, time).until(EC.element_to_be_clickable(locator))

    def find_game_cards(self, locator):  
        return self.driver.find_elements(*locator)

    def go_to_site(self):  
        return self.driver.get(self.base_url)

    def scroll_to_smth(self, element):  
        return self.driver.execute_script("arguments[0].scrollIntoView(true);", element)  
```  
> В данном примере часть реализации паттерна PageObject.  
> В базовый класс вынесены методы, которые будут использоваться на других страницах.  
> Это позволит уменьшить дублирование кода, упростит его поддержку.  
>   
#### Тесткейсы  
![](https://github.com/user-attachments/assets/7bde5aa0-ecbf-4b08-bb43-93c0abc3ed9f)  
> Таблицу с узкими колонками и горизонтальным скроллом неудобно читать и понимать.

---  
![](QA-trainee-assignment-spring-2024/images/img.png)  
   
> 68 тест-кейсов начинаются с «1. С помощью Charles...». Можно упаковать в общие предусловия.   

#### Багрепорт  
Разработчики и коллеги QA не будут рады такому описанию бага.

![](https://github.com/user-attachments/assets/89212ee4-8355-4db2-843a-3e3225e125fd)

#### Работа с Git  
![](https://github.com/user-attachments/assets/6d387cbb-bffe-4315-a7a0-de1bfabdb5f0)  
> 200+ коммитов с такими "говорящими" названиями не несут проекту никакой пользы 

---  
![](https://github.com/user-attachments/assets/942767d4-584e-4b9d-818b-2f020a6c9a4e)  
> Лаконично и понятно!

**Общий вывод:**   
1. Документируйте историю изменений понятными названиями комитов.  
2. Следите за тем, чтобы репозиторий не засорялся.  
3. Подумайте о коллеге, который будет читать ваши файлы. Сделайте их понятными и удобными:)  
