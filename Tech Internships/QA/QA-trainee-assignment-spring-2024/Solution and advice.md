### Разбор тестового задания на стажировку для QA-инженеров в Авито (весенний отбор 2024)
Тестовое состояло из двух заданий. 
В первом задании мы предлагали найти баги и определить их приоритеты на тестовой странице поисковой выдачи Авито. Во втором задании мы предлагали написать автотест.
___
### Задание 1. Поиск багов. 

**Вот на что мы обращали внимание при проверке этого задания:**

1. Количество найденных багов. Именно багов, Мы не обращали внимание, когда кандидат скатывается до придирок для пополнения их количества.  
2. Описание бага. Важно чтобы кандидаты умели правильно описывать баги, чтобы мы не пытались догадаться , что кандидат имел ввиду. При этом хорошо, если оно не избыточное.  
3. Сколько найдено критичных багов. Критичных багов в тестовом задании было не так много, поэтому важно было найти все критичные баги.  
4. Насколько точно были определены приоритеты в найденных багах. Это важный аспект при работе с багами как в тестовых заданиях так и в работе.  
5. Отдельный плюс ставили за аргументацию выставления приоритетов багов.

**Хотим поделиться советами о том, как лучше выполнять подобные задания:**

1. **Определите главную функциональность страницы**. Что может быть главной функциональностью на странице с поиском объявлений?  
    1. Поиск по тексту.  
    2. Работа фильтров.  
    3. Выдача объявлений.  
2. **Посмотрите на внешний вид**. Вам необходимо убедиться, что на странице нет багов, которые могут испортить репутацию компании.  
3. **Определите приоритеты**. Чтобы проверить себя, руководствуйтесь разделом priority/severity в ISTQB.  

___

### Задание 2. Автотест. Backend-Driven UI и микрофронтенды

В этом году при составлении тестового задания мне хотелось выйти из коробочки blackbox UI e2e тестирования и дать стажёрам пощупать что-то настоящее, чтобы они исследовали и увидели немного изнанки современных подходов к построению сервисов.
На одной странице несколько микрофронтов. Фронтенд — это только отображение данных с бекенда. Знает ли бекенд, что может, а что не может отобразить фронт? Готов ли фронтенд отобразить всё, что пришлёт ему бекенд? 

#### Текст задания:
В Avito применяются два подхода для конструирования фронтенда: Backend-driven UI и микрофронтенды.

> Backend-driven UI — это подход к проектированию интерфейсов, при котором в приложении есть набор компонентов, с которыми приложение умеет работать, а расположение, порядок и наполнение этих блоков приходят с бэкенда.
> 
> Backend-driven UI решает проблему хардкода большого количества полей в формах на клиенте, а также связей между этими полями. Если вся логика вынесена на бэкенд, то клиент становится более гибким и расширяемым с бэкенда.
>
>*https://habr.com/ru/companies/avito/articles/501698/*

Рассмотрим применение этих подходов на примере страницы «Эковклад»: https://www.avito.ru/avito-care/eco-impact

На этой странице есть три счётчика для подсчёта эковклада: CO2, воды и электроэнергии.
(см. картинку ниже)

Числа, отображаемые в этих счётчиках приходят с бэкенда. Обработкой этих чисел занимается микрофронтенд: в его задачи, например, входит отображать в счётчике только трёхзначное число, подставляя правильную приставку: вместо 1000 литров — 1 метр кубический.

Твоей задачей будет подобрать тестовые данные и протестировать поведение счётчиков.

Результатом задания должны быть: 
1. Список тест-кейсов
2. Скриншоты фактических состояний счётчика
3. Инструкция для получения скриншотов
4. Опционально: список багов

Подсказка №1: Старайся использовать техники тест-дизайна и минимизировать количество тест-кейсов.

Подсказка №2: Выполнить это задание можно используя разные подходы, и мы никак не ограничиваем тебя в применяемых инструментах, но намекнём, что для выполнения задания хватит и браузера =)

#### Как мы оценивали задание:
Довольно легко сказать «это плохой код». Нарушение договорённостей языка, неясность логики, сумбурная структура — яркие маркеры. Но вот сказать «этот код лучше» — сложнее. Тут начинается субъективщина. 
Ещё сложнее понять, что перед тобой хороший автотест. Вопрос про «критерии хорошего автотеста» часто встречается на собеседованиях, и на него можно ответить с разной степенью детальности.
«Атомарный, читаемый, стабильный...» — набор характеристик можно продолжать, я встречал списки, в которых было по 25 пунктов.
Но кончается ли дело автотестом? Для чего он вообще написан? Так ли важен его код?

Я предлагаю вам посмотреть на кусочки вариантов выполненного задания от тех ребят, кто прошёл строгий отбор и получил оффер на стажировку. Они в сжатые сроки справились лучше остальных — это уже достойно похвалы.
Рассматривая эти фрагменты, попробуйте встать в позицию проверяющего — что для вас было бы важно при проверке?
Вообще для QA очень важно умение смотреть на мир «от лица» кого-то: нового пользователя, сотрудника поддержки, коллеги QA.

#### Структура проекта
Структура проекта, логика директорий и наименований файлов — это всё часть культуры работы с кодом.
Если взять самые красивые, понятные и стабильные автотесты и сложить их в папочку «new folder» с именами test_1, test_2 — они сразу станут непонятными и некрасивыми.
Примеры: 

* Иерархичная стурктура, понятные названия* 

![](QA-trainee-assignment-spring-2024/images/img_4.png)

* Плоская структура с безликими именами*

![](QA-trainee-assignment-spring-2024/images/img_5.png)

#### Инструкция 
Инструкция. Чем проще, тем лучше: склонировать, установить зависимости, запустить.
Примеры: 

*В меру подробная инструкция*

1. Склонируйте к себе репозиторий, в котором хранится проект тестового задания, через выполнение команды в терминале
    ```
    git clone https://github.com/Herzenswearme/AvitoTech_QA-trainee.git
    ```
    Или скачайте zip архив по [ссылке](https://github.com/Herzenswearme/AvitoTech_QA-trainee/archive/refs/heads/main.zip) и распакуйте его


2. Убедитесь, что на Вашем компьютере установлен Python. В командной строке/терминале выполните команду
    ```
    python -v
    ```  
    Если он не установлен, то установите с официального [сайта Python](https://www.python.org/downloads/), выбрав подходящую версию для Вашей операционной системы, и пройдите шаг сначала.  В процессе установки обязательно поставьте галочку в чекбоксе "Add python.exe to PATH". Иначе, у Вас не будет корректно отображаться версия Python

3. Через командную строку/терминал перейдите в корневую директорию проекта, выполнив команду
   ```
   cd /здесь укажите путь до директории с проектом
   ```

4. Установите необходимые зависимости из файла `requirements.txt`, выполнив команду  
   ```
   pip install -r requirements.txt
   ```
   если она не выполняется, то попробуйте
   ```
   pip3 install -r requirements.txt
   ```
5. После успешной установки зависимостей, установите необходимые бинарные файлы браузеров, выполнив команду
   ```
   playwright install
   ```
   
6. Наконец, запустите тесты, выполнив команду  
   ```
   pytest -v
   ```
> Очень приятная инструкция, написанная живым человеческим языком. От такой инструкции веет теплотой и заботой. Уже здесь чувствуется, что у кандидата отличные софт-скиллы!

*До жестокости подробная (и усложнённая) инструкция* 
1. Открыть PyCharm.
2. В верхнем меню навести курсором на “File”.
3. В выпадающем списке нажать на “New Project..”.
4. Поставить чек-бокс на “Create a main.py welcome script”.
5. Нажать кнопку “Create”.
6. Нажать кнопку “This Window”.
7. Вернуться в GitHub и скопировать код из файла “test.py”.
8. Вернуться в PyCharm и вставить скопированный код в созданный файл main.py.
9. Открыть терминал(В нижнем левом углу нажать на значок  квадрата внутри символы >_) . Откроется терминал.
10. Написать в терминале команду pip install pytest-playwright. Подождать, когда закончится загрузка.
11. Написать в терминале команду playwright install. Подождать, когда закончится загрузка.
12. Для получения скриншотов для счетчика воды нажать на зеленый треугольник находящийся рядом с функцией def test\_water(page: Page): . Нажать на Run.
13. Подождать, когда функция завершит работу.
14. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_water
15. Для получения скриншотов для счетчика CO2 нажать на зеленый треугольник находящийся рядом с функцией def test\_co2(page: Page): . Нажать на Run.
16. Подождать, когда функция завершит работу.
17. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_co2
18. Для получения скриншотов для счетчика энергии нажать на зеленый треугольник находящийся рядом с функцией def test\_energy(page: Page): . Нажать на Run.
19. Подождать, когда функция завершит работу.
20. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_ energy
21. Слева появится папка с названием “output”. В ней расположены полученные скриншоты. 

> Вместо первых 8 пунктов можно было просто написать «склонируйте репозиторий». Хотя даже это лишнее. 

#### Параметризация
Сила автотестов — в повторяемости. Вы берёте входные данные, описываете в коде действия с ними и свои ожидания от результата.
Если действия одни и те же, а меняются только входные данные — это нужно параметризировать! 

---
```python
    a = [1, 999, 1000, 1001, 9954, 9955, 10000, 10001, 10049, 10050, 99950, 100000, 100499, 100500, 999449, 999500,
          1000000, 1044000, 1045000, 999449000, 999500000, 1000000000]
    for i, elem in enumerate(a):
        page.goto("https://www.avito.ru/avito-care/eco-impact", wait_until="domcontentloaded")
```
> Однобуквенная переменная, хранящая все кейсы в одном списке — трудная для восприятия структура.

---
```python
@pytest.mark.parametrize('co2, energy, materials, pine_years, water, test_case', (
        (0, 0, 0, 0, 0, 'TK-1'),
        (999, 999, 999, 999, 999, 'TK-2'),
        (1000, 1000, 1000, 1000, 1000, 'TK-3'),
        (1500, 1500, 1500, 1500, 1500, 'TK-4'),
        (1000000, 1000000, 1000000, 1000000, 1000000, 'TK-5'),
        (1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000, 'TK-6'),
        (1000000000000000, 1000000000000000, 1000000000000000, 1000000000000000, 1000000000000000, 'TK-7'),
        (-1, -1, -1, -1, -1, 'TK-8'),
))
```
> Использована параметризация, кейсы объединены в классы эквивалентности, у кейсов есть имя.
> Что можно улучшить: здесь очевидно можно избавиться от дублирования чисел. 
---

```python
        replaceable_responses = [
            generate_response(co2=1, energy=50, water=999),  # ОР: co2 = 1 кг, energy = 50 кВт/ч, water = 999 л
            generate_response(co2=1000, energy=1000, water=1000),  # ОР: co2 = 1 т, energy = 1 МВт/ч, water = 1 м3
            generate_response(co2=1000000, energy=1000000, water=1000000),  # ОР: co2 = 1 тыс. т, energy = 1 тыс. МВт/ч, water = 1 тыс. м3
            generate_response(co2=1000000000, energy=1000000000, water=1000000000),  # ОР: co2 = 1 млн. т, energy = 1 млн. МВт/ч, water = 1 млн. м3
            generate_response(co2=1000000000000, energy=1000000000000, water=1000000000000),  # ОР: co2 = 1 млрд. т, energy = 1 млрд. МВт/ч, water = 1 млрд. м3
            generate_response(co2=1000000000000000, energy=1000000000000000, water=1000000000000000)  # ОР: co2 = 1 квдрлн. т, energy = 1 квдрлн. МВт/ч, water = 1 квдрлн. м3
        ]
```
> Использованы комментарии для хранения ожидаемого результата. Но не очень удачно — горизонтальный скролл — это плохо.
> Однако, почему-то в первом кейсе использованы разные значения 🤔
> Ещё никто не улучшил читаемость больших чисел используя встроенные в пайтон способы, например `1_000_000` или `10**9`

---
```go
// Граница конвертации в тонны
	{
		testName:    "Energy 998",
		description: "Класс [0:1000) шаг в границу ",
		energyValue: 998,
	},
	{
		testName:    "Energy 999",
		description: "Класс [0:1000) граничное значение и шаг за границу для класса [1000:1000000)",
		energyValue: 999,
	},
	{
		testName:    "Energy 1000",
		description: "Класс [0:1000) шаг за границу и граничное значение для класса [1000:1000000)",
		energyValue: 1000,
	},
	{
		testName:    "Energy 1001",
		description: "Шаг за границу для класса [1000:1000000)",
		energyValue: 1001,
	},
	{
		testName:    "Energy 550000",
		description: "Класс [1000:1000000) типичный представитель",
		energyValue: 550000,
	},
```
> Параметризация с помощью структуры позволяет максимально полно описать что и почему тестируется.

#### Тесткейсы
![](QA-trainee-assignment-spring-2024/images/img_7.png)
> Таблицу с узкими колонками и горизонтальным скроллом неудобно читать и понимать.

---
![](QA-trainee-assignment-spring-2024/images/img.png)
 
> 68 тест-кейсов начинаются с «1. С помощью Charles...». Можно упаковать в общие предусловия.   

#### Багрепорт
Чёткая структура, багрепорт — как карточка, которая помещается на один экран. Круто!

![](QA-trainee-assignment-spring-2024/images/img_6.png)

#### Работа с Git
![](QA-trainee-assignment-spring-2024/images/img_1.png)
> Коммит с названием "1" лучше переименовать так, чтобы было понятно, что внутри коммита. 

---
![](QA-trainee-assignment-spring-2024/images/img_2.png)
> Здесь вся работа над тестами уложилась в час времени. Весьма похвальная скорость!

---
![](QA-trainee-assignment-spring-2024/images/img_3.png)
> .DS_Store — этот файл не несёт информации о проекте или исходном коде, лучше убрать

**Общий вывод:** 
1. Документируйте историю изменений понятными названиями комитов
2. Следите за тем, чтобы репозиторий не засорялся
3. Подумайте о коллеге, который будет читать ваши файлы. Сделайте их понятными и удобными:)
