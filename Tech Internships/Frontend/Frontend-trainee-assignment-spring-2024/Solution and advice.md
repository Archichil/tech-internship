# Введение
Авито заинтересован в том, чтобы вы хорошо выполнили свои задания при отборе на программы стажировок. Наши разработчики захотели поделиться с вами своим опытом и написали статью о лучших подходах в написании frontend-приложений, а также о самых частых ошибках, которые совершают кандидаты в своих работах. Все совпадения конечно же случайны. :)

# Насмотренность
Задания в Авито подбираются таким образом, чтобы у выполняющих был простор для творчества. Попробуйте посмотреть на свою работу не как разработчик, а как обычный пользователь – у каждого из нас имеется опыт использования всевозможных приложений. 
Вот список наиболее частых нюансов, о которых забывают кандидаты:
## Ховеры
Современные пользователи привыкли, что при наведении на элементы, с которыми можно взаимодействовать, стрелка курсора превращается в маленькую ручку. Когда такого не происходит, это слегка сбивает с толку.
## Раскрывашки
При выведении списка элементов помните, что некоторые из них могут содержать чрезмерно большое количество контента. Например, разгневанный посетитель маркетплейса может оставить под карточкой товара огромный обличающий комментарий. Согласитесь, не очень удобно, когда один особо длинный текст занимает большую часть пространства. Обычно к таким компонентам добавляют кнопку, позволяющая раскрывать весь контент, а по умолчанию он частично скрыт.
## Поиск
Компонент поиска не так прост, как кажется на первый взгляд. При его разработке следует учитывать несколько моментов:
* Как будет осуществляться запрос к серверу: по нажатию кнопки “Найти” или сразу при введении текста в поисковую строку? Если второй вариант, то тут обязательно надо использовать декоратор (или хук) debounce.  
* При каком количестве введенных букв начинает работать поиск? (обычно ставят ограничение от 3 символов)  
* Будет ли у вашего компонента история поиска? Если да, как именно вы ее реализуете? Желательно чтобы история сохранялась между перезагрузками, для этого нужно ее сохранять например в localStorage, а также следить за количеством сохраненных значений.

## Фильтры
Реализация фильтра – отдельная головная боль. Здесь необходимо очень хорошо подумать, в каких случаях какие способы исполнения будут наиболее удобны пользователю.
* Если у нас имеется возможность выбирать одновременно несколько вариантов, хорошо подойдут чекбоксы. (пример: “Страны”, “Жанры”)  
* Для того, чтобы выбрать лишь один конкретный вариант из множества, подойдет выпадающий список или кастомизированный radio button. (пример: “Категория” товара)  
* Когда необходимо отобразить промежутки чисел, можно использовать слайдеры – при помощи движения ползунков выставляются конкретные интервалы. (пример: “Года”)  
* Булевое значение удобно представляется в виде свитчера (пример: “Баллы за отзыв” в фильтре поиска товаров на известном маркетплейсе).
## Скроллы
Скроллы – удобная штука, когда весь контент не помещается в отведенном для него месте. Но почему-то многие кандидаты забывают явно указывать его наличие в компоненте. То есть пользователь может даже не знать, что он видит лишь часть содержимого, если ползунок скролла отображается только при наведении на конкретную область страницы.
## Лоадеры
Лоадеры – это компоненты, которые оповещают пользователя о том, что в приложении происходят определенные процессы и требуется немного подождать. Компоненты необходимо отображать во время того, как мы совершаем асинхронный запрос к серверу. В противном случае, пока не пришли данные от бэка, приложение будет показывать пустую страницу. Пользователь подумает, что страница залагала и уйдет, не дождавшись отрисовки данных. Возможно, вам кажется, что мы сейчас озвучиваем очевидные вещи. Но в определенной части рассмотренных нами проектов, лоадеров не было.
## Обработка ошибок
Кроме лоадинга хорошей практикой является обработка возможных ошибок и пустых значений. Круто, если компонент, отображающий ошибку, предлагает какой-то вариант для дальнейших действий, например, вернуться на предыдущую страницу, перезагрузить, либо написать в техподдержку.
# Общие рекомендации
Здесь мы собрали для вас общие рекомендации по сборке и написанию проекта, чтобы вам было удобнее разрабатывать приложение, а проверяющему проще и приятнее просматривать вашу работу.
## Переменные окружения
Зачастую в заданиях от Авито требуется работать с какой-то готовой api, и доступ к этой api предоставляется по уникальному ключу. Напрямую хардкодить этот ключ – не лучший вариант. Самый простой способ – использовать переменные окружения (должен быть добавлен в gitignore):
* В конфиге Webpack подключается плагин new Dotenv().  
* А сам ключ вписывается в специальный .env файл. 
## Зависимости
В package.json есть раздел dependencies, а есть devDependencies. У разработчиков считается хорошей практикой зависимости, которые нужны только во время разработки, отправлять в devDependencies.
## Архитектура
Есть различные подходы к архитектуре frontend-приложения. Например, сейчас у всех на слуху FSD (Feature-Sliced Design). FSD хорошо подходит для крупных проектов,в остальных случаях можно прибегать к более компактным решениям. Будет классно, если еще до разработки вы определитесь с архитектурным подходом и обоснуете его выбор в README.

![image](images/1.png)
## Конфигурирование Webpack
Огромным плюсом будет, если вы самостоятельно напишите конфигурацию для Webpack. Она может быть сделана в виде одного файла webpack.config.ts. А можно ее разделить на логические блоки, что прибавит вам дополнительных баллов в глазах проверяющего.  
[image](https://drive.google.com/file/d/1HYbbziwYuB49szKsvLU3rahnCEp43Fh-/view?usp=sharing)
## История коммитов
В командной разработке важно понимать когда и для каких целей был написан тот или иной кусок кода. Так же иногда требуется откатить какой-то функционал. Для этого важно разбивать функционал по коммитам и давать им понятные описания.  
[image](https://drive.google.com/file/d/1HJhTH1xjZ8jCv8SLOSbWVd9A9l1CXla0/view?usp=sharing)
## Лайки и прочие питомцы
Относитесь с особым подозрением к тому, с чем будут часто взаимодействовать пользователи. Например, считается хорошей практикой компонент, отображающий лайки, а так же все состояния, необходимые для его работы, выделять в независимый дочерний компонент. Ведь пользователи – люди не постоянные, сейчас им что-то нравится, а через минуту – уже нет. Они могут дергать несчастное сердечко туда и обратно по многу раз, что будет вызывать лишние перерисовки, если не вынести лайки из большого компонента.
## Разделение логики и представления
Когда логика и представление перемешаны, код становится сложно читать и поддерживать. Хорошей практикой является группировка логики по функциональности и вынесение ее в утилиты или кастомные хуки.  
[image](https://drive.google.com/file/d/1Pw3ECYYXepX5fEl63Uqlb9rLC73ciWrs/view?usp=sharing)
## Размеры компонентов
Большие компоненты сложнее поддерживать. При внесении правок приходится много скролить или даже пользоваться поиском по файлу, части большого компонента невозможно переиспользовать, а еще возможны частые конфликты версий при командной разработке. Поэтому, если компонент становиться большим, лучше разбить его на несколько более мелких.

## Юнит-тесты
Написание юнит-тестов не только проверяет корректность работы вашего кода, но и побуждает писать более модульный и чистый код. Большим плюсом будет если вы покроете какую-то часть кода юнит-тестами.
## Неиспользуемые переменные
Убедитесь, что в вашем коде все переменные применяются по назначению. Вы удивитесь, но в большом количестве работ присутствовали переменные, которые нигде не используются. Это конечно не критичное упущение, но все же создает определенное впечатление.
## Readme
Удобно, когда в приложении есть *readme.md* файл, в котором описана информация по запуску сервиса и возможных нюансах работы с приложением. В тестовых заданиях также приветствуется описание используемых технологий и функционала, который был выполнен, а также проблем, с которыми вы столкнулись при разработке. Это является дополнительным плюсом при проверке.
## Линтер
Линтер (см., например, *ESLint*) помогает сделать код чище и понятнее. Кроме того, он помогает искать баги и стилистические ошибки. Также можно настроить *prettier* для поддержания консистентности форматирования.
## Консоль
Перед окончательной публикацией своей работы заново пройдитесь по всем страницам. Примерно у 80% кандидатов их приложение публикует лишние данные в консоль. Это могут быть:
* Warning \- замечания о некритичных проблемах в приложении.  
* Error \- ошибки, которые серьезно влияют на работоспособность приложения.  
* *console.log* \- для отладки разработчики частенько выводят какую-то информацию в консоль, а потом забывают все добавленные console.log убирать из кода. Чтобы было проще отслеживать такие моменты, можно добавить правило ESLint “*no-console*”. Или вместо *console.log* использовать ключевое слово *debugger*.

# Частые ошибки в коде
Данный блок реализован в виде небольших задачек на подумать. Для самопроверки вы можете попытаться самостоятельно ответить на вопрос, а уже после прочитать ответ.
[image](https://drive.google.com/file/d/1d_Ggcv_3u7Cva4uXrBhzWOosxfuhYc-g/view?usp=sharing)
### Вопрос: 
Пользователь вводит в поисковую строку какое-то значение, но на сервер мы запрос отправляем не сразу (чтобы не создавать лишние). Вешаем таймер, который срабатывает по истечению определенного времени. Но чего здесь не хватает, чтобы наша задумка отработала как надо?
### Ответ:
В текущем коде каждый раз при обновлении *value* будет создаваться множество таймеров, которые начнут нагружать браузер пользователя. Чтобы этого избежать, необходимо в хуке очищать таймер, если пользователь продолжает ввод. Как это сделать? (подсказка: *return* в *useEffect*)
[image](https://drive.google.com/file/d/1xYWexGCn_ze51cG0dyYuQR06FuVSLMJY/view?usp=sharing)
### Вопрос: 
Массив фильмов *films*, который методом *map* преобразуется в список карточек с данными фильмов. Чего здесь не хватает?

### Ответ:
* Не хватает атрибута *key*. Зачем он нужен? (подсказка: Виртуальный дом в React и reconciliation)  
* При перечислении каких-то элементов считается семантически верным использовать неупорядоченный список. Но на практике так делают далеко не всегда, так что данное решение остается на ваше усмотрение.

[image](https://drive.google.com/file/d/1i9H2PK4PCRZvFJJR8soV1MSCEaX39Y0O/view?usp=sharing)
### Вопрос: 
И снова знакомый нам список фильмов. На этот раз разработчик не забыл добавить атрибут *key*. И все же что-то в коде определенно не так, но что?
### Ответ:
Когда пользователь хочет найти какой-то фильм, хук *useQueryFilms* делает запрос к серверу, чтобы получить массив фильмов (*films*) исходя из введенных пользователем данных (*query*). Но что случится, если сервер вернет ошибку? Должен вывестись компонент *ErrorMessage*. Однако перед этим код попытается выполнить метод *map* на переменной *films*, которая не будет массивом (ведь сервер нам не отдал массив фильмов). Приложение выдаст ошибку. Как это можно исправить?
Можно использовать оператор ***?.*** или оператор ***||***. Однако зачем заставлять приложение выполнять лишнюю работу, если переменная *filmsItems* нам в принципе не нужна? Если у нас есть какие-то вычисления, выполняемые не в хуках, а также присутствуют альтернативные варианты отображения по каким-то условиям (*if (isError) {...}*, *if (isLoading) {...}* и т.д.), делайте эти проверки по возможности как можно раньше в коде.

[image](https://drive.google.com/file/d/1qXN0KOgCOJW4Zb0cXyNT_YdIxrjP9c9a/view?usp=sharing)

### Вопрос: 
Здесь мы выводим карточку сериала. Она содержит: постер, название и количество серий. Прям явных ошибок тут нет, но все же пару недочетов проверяющий нашел. А вы нашли?
### Ответ:
Сначала отметим, что хорошо – в коде используется шаблонная строка, которая прекрасно подходит для вывода динамически меняющихся строковых данных. Но вот название компонента слишком абстрактное. О том, что делает компонент, мы можем лишь косвенно догадаться по принимаемым им пропсам. Конкретизируйте названия компонентов, функций и переменных, чтобы даже при беглом взгляде каждый разработчик понимал, для чего нужен этот код. В данном примере компонент *Element* мы могли бы назвать *SerialItem*. Также было бы неплохо просклонять слово *“серий”*, ведь у нас может быть и одна *“серия”*.

[image10](https://drive.google.com/file/d/1pGluyLyYN9hoBegOzdOCAWc055R3m5i5/view?usp=sharing)

### Вопрос: 
В каких случаях мы создаем константы через *let*, а в каких через *const*? Почему в данном примере *let* неуместно?
### Ответ:
Здесь переменную *id* мы получаем из хука *react-router-dom*. В принципе, за изменение переменных, получаемых из хуков, отвечают эти самые хуки. Потому очевидно, что в текущем коде *id* мы не будем менять, а значит правильнее было бы ее объявить через *const*.
[image11](https://drive.google.com/file/d/1ixH-8y9XTyvbsWe8HGU6VXn185E3Jmm4/view?usp=sharing)

### Вопрос: 
Какие хорошие практики вы знаете для работы с импортами?
### Ответ:
* Импорты тут написаны правильно, но выглядят они неаккуратно. Прокидывайте, где это возможно, импорты через *index.ts*, чтобы итоговые импорты имели более компактный вид. В данном случае мы можем получить:  
  *import { Rating } from "../../components/Rating";*  
  *import { ReviewsList } from "../../components/ReviewsList";*  
  *import { ActorsList } from "../../components/ActorsList";*  
    
  Или даже:  
  *import { Rating, ReviewsList, ActorsList } from "../../components";*  
* С импортами можно еще больше поиграться и сделать их абсолютными. Это задание со звездочкой. Попробуйте выяснить, как это можно сделать (подсказка: ищите в настройках конфига Webpack).

# Заметки:
* Выносить константы вне компонента  
* Дубликаты
